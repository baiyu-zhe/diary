<template>
  <!-- è¿™æ˜¯ä¸€ä¸ªæ— æ¸²æŸ“ç»„ä»¶ï¼Œä»…ç”¨äºç®¡ç†åŠ¨æ€å£çº¸ -->
</template>

<script setup lang="ts">
import { onMounted, onUnmounted, nextTick } from 'vue'
import { fetchDynamicWallpapers, WALLPAPER_SERVICE_CONFIG } from '../../ConfigHyde/Wallaper'

// å®šä¹‰æ—¶é—´é—´éš”é…ç½®
const FETCH_LIBRARY_INTERVAL = 60 * 1000 // 60ç§’è¯·æ±‚ä¸€æ¬¡å›¾é›†æœåŠ¡å™¨è·å–å›¾åº“
const SWITCH_IMAGE_INTERVAL = 10 * 1000 // 10ç§’ä»å›¾åº“ä¸­éšæœºé€‰æ‹©ä¸€å¼ å›¾ç‰‡å±•ç¤º
const SERVICE_CHECK_INTERVAL = 15 * 1000 // 15ç§’æ£€æµ‹ä¸€æ¬¡æœåŠ¡çŠ¶æ€ï¼ˆå½“ä½¿ç”¨å¤‡ç”¨å›¾ç‰‡æ—¶ï¼‰

let fetchLibraryIntervalId: number | null = null // å›¾åº“è¯·æ±‚å®šæ—¶å™¨
let switchImageIntervalId: number | null = null // å›¾ç‰‡åˆ‡æ¢å®šæ—¶å™¨
let serviceCheckIntervalId: number | null = null // æœåŠ¡æ£€æµ‹å®šæ—¶å™¨
let currentImages: string[] = [] // å½“å‰å›¾åº“
let currentDisplayImage: string = '' // å½“å‰å±•ç¤ºçš„å›¾ç‰‡
let isUsingFallback: boolean = false // æ˜¯å¦æ­£åœ¨ä½¿ç”¨å¤‡ç”¨å›¾ç‰‡
let lastSuccessfulFetch: number = 0 // ä¸Šæ¬¡æˆåŠŸè·å–å›¾åº“çš„æ—¶é—´

// é¢„åŠ è½½å›¾ç‰‡ä»¥é¿å…åŠ è½½é—ªçƒï¼Œæ£€æµ‹å›¾ç‰‡æ˜¯å¦å¯ç”¨
function preloadImage(src: string): Promise<boolean> {
  return new Promise((resolve) => {
    const img = new Image()
    img.onload = () => resolve(true) // åŠ è½½æˆåŠŸ
    img.onerror = () => resolve(false) // åŠ è½½å¤±è´¥
    img.src = src
  })
}

// æ·»åŠ è¿‡æ¸¡åŠ¨ç”»æ ·å¼
function addTransitionStyles(element: HTMLElement) {
  if (!element.style.transition || !element.style.transition.includes('opacity')) {
    element.style.transition = element.style.transition 
      ? `${element.style.transition}, opacity 0.3s ease-in-out`
      : 'opacity 0.3s ease-in-out'
  }
}

// æ›´æ–°BannerèƒŒæ™¯å›¾ç‰‡ï¼ˆä½¿ç”¨æ»‘åŠ¨è¿‡æ¸¡ï¼Œé¿å…ç™½é—ªï¼‰
function updateBannerBackground(imageSrc: string): boolean {
  const bannerEl = document.querySelector('.tk-banner')
  const bannerBg = bannerEl?.querySelector('.tk-banner__bg, .tk-banner-bg, [class*="banner"][class*="bg"]') as HTMLElement
  
  if (bannerBg) {
    // ä¿å­˜å½“å‰æ ·å¼
    const currentStyles = {
      backgroundSize: bannerBg.style.backgroundSize || 'cover',
      backgroundPosition: bannerBg.style.backgroundPosition || 'center center',
      backgroundRepeat: bannerBg.style.backgroundRepeat || 'no-repeat'
    }
    
    // è·å–å½“å‰èƒŒæ™¯å›¾ç‰‡
    const currentBg = bannerBg.style.backgroundImage
    
    // å¦‚æœæœ‰å½“å‰å›¾ç‰‡ï¼Œä½¿ç”¨æ»‘åŠ¨è¿‡æ¸¡
    if (currentBg && currentBg !== 'none' && currentBg !== '') {
      // è®¾ç½®åŒå±‚èƒŒæ™¯è¿›è¡Œæ»‘åŠ¨è¿‡æ¸¡
      bannerBg.style.backgroundImage = `url("${imageSrc}"), ${currentBg}`
      bannerBg.style.backgroundSize = `${currentStyles.backgroundSize}, ${currentStyles.backgroundSize}`
      bannerBg.style.backgroundRepeat = `${currentStyles.backgroundRepeat}, ${currentStyles.backgroundRepeat}`
      
      // è®¾ç½®åˆå§‹ä½ç½®ï¼šæ–°å›¾ç‰‡åœ¨å³ä¾§ï¼Œæ—§å›¾ç‰‡åœ¨æ­£å¸¸ä½ç½®
      bannerBg.style.backgroundPosition = `120% center, ${currentStyles.backgroundPosition}`
      bannerBg.style.transition = 'background-position 2s cubic-bezier(0.25, 0.46, 0.45, 0.94)'
      
      // å»¶è¿Ÿä¸€å¸§ç¡®ä¿æ ·å¼åº”ç”¨
      requestAnimationFrame(() => {
        // æ»‘åŠ¨è¿‡æ¸¡ï¼šæ–°å›¾ç‰‡æ»‘å…¥ä¸­å¿ƒï¼Œæ—§å›¾ç‰‡æ»‘å‡ºå·¦ä¾§
        bannerBg.style.backgroundPosition = `${currentStyles.backgroundPosition}, -120% center`
        
        // è¿‡æ¸¡å®Œæˆåæ¸…ç†
        setTimeout(() => {
          bannerBg.style.backgroundImage = `url("${imageSrc}")`
          bannerBg.style.backgroundSize = currentStyles.backgroundSize
          bannerBg.style.backgroundPosition = currentStyles.backgroundPosition
          bannerBg.style.backgroundRepeat = currentStyles.backgroundRepeat
          bannerBg.style.transition = ''
        }, 2000)
      })
    } else {
      // é¦–æ¬¡è®¾ç½®ï¼Œç›´æ¥åº”ç”¨
      bannerBg.style.backgroundImage = `url("${imageSrc}")`
      bannerBg.style.backgroundSize = currentStyles.backgroundSize
      bannerBg.style.backgroundPosition = currentStyles.backgroundPosition
      bannerBg.style.backgroundRepeat = currentStyles.backgroundRepeat
    }
    
    console.log('å·²æ›´æ–°BannerèƒŒæ™¯å›¾ç‰‡:', imageSrc)
    return true
  }
  
  // å°è¯•æ›´æ–°æ‰€æœ‰å¯èƒ½çš„èƒŒæ™¯å…ƒç´ 
  const backgroundElements = document.querySelectorAll(
    '[style*="background-image"], .banner-bg, .tk-banner-bg, .background-image'
  ) as NodeListOf<HTMLElement>
  
  let updated = false
  backgroundElements.forEach(element => {
    if (element.style.backgroundImage && element.style.backgroundImage.includes('http')) {
      const currentStyles = {
        backgroundSize: element.style.backgroundSize || 'cover',
        backgroundPosition: element.style.backgroundPosition || 'center center',
        backgroundRepeat: element.style.backgroundRepeat || 'no-repeat'
      }
      
      const currentBg = element.style.backgroundImage
      
      // å¦‚æœæœ‰å½“å‰å›¾ç‰‡ï¼Œä½¿ç”¨æ»‘åŠ¨è¿‡æ¸¡
      if (currentBg && currentBg !== 'none' && currentBg !== '') {
        // è®¾ç½®åŒå±‚èƒŒæ™¯è¿›è¡Œæ»‘åŠ¨è¿‡æ¸¡
        element.style.backgroundImage = `url("${imageSrc}"), ${currentBg}`
        element.style.backgroundSize = `${currentStyles.backgroundSize}, ${currentStyles.backgroundSize}`
        element.style.backgroundRepeat = `${currentStyles.backgroundRepeat}, ${currentStyles.backgroundRepeat}`
        
        // è®¾ç½®åˆå§‹ä½ç½®ï¼šæ–°å›¾ç‰‡åœ¨å³ä¾§ï¼Œæ—§å›¾ç‰‡åœ¨æ­£å¸¸ä½ç½®
        element.style.backgroundPosition = `120% center, ${currentStyles.backgroundPosition}`
        element.style.transition = 'background-position 2s cubic-bezier(0.25, 0.46, 0.45, 0.94)'
        
        // å»¶è¿Ÿä¸€å¸§ç¡®ä¿æ ·å¼åº”ç”¨
        requestAnimationFrame(() => {
          // æ»‘åŠ¨è¿‡æ¸¡ï¼šæ–°å›¾ç‰‡æ»‘å…¥ä¸­å¿ƒï¼Œæ—§å›¾ç‰‡æ»‘å‡ºå·¦ä¾§
          element.style.backgroundPosition = `${currentStyles.backgroundPosition}, -120% center`
          
          // è¿‡æ¸¡å®Œæˆåæ¸…ç†
          setTimeout(() => {
            element.style.backgroundImage = `url("${imageSrc}")`
            element.style.backgroundSize = currentStyles.backgroundSize
            element.style.backgroundPosition = currentStyles.backgroundPosition
            element.style.backgroundRepeat = currentStyles.backgroundRepeat
            element.style.transition = ''
          }, 2000)
        })
      } else {
        // é¦–æ¬¡è®¾ç½®ï¼Œç›´æ¥åº”ç”¨
        element.style.backgroundImage = `url("${imageSrc}")`
        element.style.backgroundSize = currentStyles.backgroundSize
        element.style.backgroundPosition = currentStyles.backgroundPosition
        element.style.backgroundRepeat = currentStyles.backgroundRepeat
      }
      
      updated = true
    }
  })
  
  return updated
}

// ä»å½“å‰å›¾åº“ä¸­éšæœºé€‰æ‹©ä¸€å¼ å›¾ç‰‡å±•ç¤ºï¼ˆå¸¦å»é‡é€»è¾‘ï¼‰
async function displayRandomImage() {
  // æ£€æŸ¥å›¾åº“æ˜¯å¦ä¸ºç©º
  if (!currentImages || currentImages.length === 0) {
    console.warn('å›¾åº“ä¸ºç©ºï¼Œä½¿ç”¨å¤‡ç”¨å›¾ç‰‡')
    currentImages = getFallbackImages()
    isUsingFallback = true
  }
  
  let availableImages = currentImages
  
  // å¦‚æœå›¾åº“ä¸­æœ‰å¤šå¼ å›¾ç‰‡ï¼Œæ’é™¤å½“å‰æ­£åœ¨å±•ç¤ºçš„å›¾ç‰‡
  if (currentImages.length > 1 && currentDisplayImage) {
    availableImages = currentImages.filter(img => img !== currentDisplayImage)
  }
  
  // å¦‚æœè¿‡æ»¤åæ²¡æœ‰å›¾ç‰‡äº†ï¼Œä½¿ç”¨å…¨éƒ¨å›¾ç‰‡
  if (availableImages.length === 0) {
    availableImages = currentImages
  }
  
  const randomImg = availableImages[Math.floor(Math.random() * availableImages.length)]
  
  // å¦‚æœé€‰ä¸­çš„å›¾ç‰‡å’Œå½“å‰å±•ç¤ºçš„ç›¸åŒï¼Œç›´æ¥è¿”å›ï¼ˆé¿å…ä¸å¿…è¦çš„æ›´æ–°ï¼‰
  if (randomImg === currentDisplayImage) return
  
  try {
    // é¢„åŠ è½½å›¾ç‰‡å¹¶æ£€æµ‹æ˜¯å¦æˆåŠŸ
    const preloadSuccess = await preloadImage(randomImg)
    
    // å¦‚æœå›¾ç‰‡åŠ è½½å¤±è´¥ä¸”å½“å‰ä½¿ç”¨çš„æ˜¯åŠ¨æ€å›¾åº“ï¼Œåˆ‡æ¢åˆ°å¤‡ç”¨å›¾ç‰‡
    if (!preloadSuccess && !isUsingFallback) {
      console.warn('ğŸ”Œ åŠ¨æ€å›¾ç‰‡åŠ è½½å¤±è´¥ï¼ŒæœåŠ¡å¯èƒ½å·²åœæ­¢ï¼Œåˆ‡æ¢åˆ°å¤‡ç”¨å›¾ç‰‡')
      currentImages = getFallbackImages()
      isUsingFallback = true
      
      // å¯åŠ¨æœåŠ¡ç›‘æ§
      startServiceMonitoring()
      
      // é‡æ–°ä»å¤‡ç”¨å›¾åº“é€‰æ‹©å›¾ç‰‡
      const fallbackImg = currentImages[Math.floor(Math.random() * currentImages.length)]
      const fallbackPreloadSuccess = await preloadImage(fallbackImg)
      
      if (fallbackPreloadSuccess) {
        currentDisplayImage = fallbackImg
        updateBannerBackground(fallbackImg)
        return
      } else {
        console.error('å¤‡ç”¨å›¾ç‰‡ä¹ŸåŠ è½½å¤±è´¥')
        return
      }
    } else if (!preloadSuccess) {
      // å¤‡ç”¨å›¾ç‰‡ä¹ŸåŠ è½½å¤±è´¥ï¼Œè·³è¿‡æ­¤æ¬¡æ›´æ–°
      console.warn('å›¾ç‰‡åŠ è½½å¤±è´¥ï¼Œè·³è¿‡æ­¤æ¬¡æ›´æ–°')
      return
    }
    
    // æ›´æ–°å½“å‰å±•ç¤ºå›¾ç‰‡è®°å½•
    currentDisplayImage = randomImg
    
    // æ›´æ–°BannerèƒŒæ™¯
    const success = updateBannerBackground(randomImg)
    
    if (!success) {
      // å¦‚æœç«‹å³æ›´æ–°å¤±è´¥ï¼Œç­‰å¾…DOMæ›´æ–°åå†è¯•
      await nextTick()
      updateBannerBackground(randomImg)
    }
    
    // è®¾ç½®å…¨å±€å˜é‡ä¾›å…¶ä»–ç»„ä»¶ä½¿ç”¨
    ;(window as any).dynamicWallpapers = currentImages
    
    // è§¦å‘è‡ªå®šä¹‰äº‹ä»¶
    window.dispatchEvent(new CustomEvent('wallpaper-updated', {
      detail: { images: currentImages, currentImage: randomImg }
    }))
    
    const imageType = isUsingFallback ? 'å¤‡ç”¨' : 'åŠ¨æ€'
    console.log(`ğŸ¨ å·²åˆ‡æ¢${imageType}å£çº¸:`, randomImg)
    
  } catch (error) {
    console.warn('åˆ‡æ¢å£çº¸å¤±è´¥:', error)
  }
}


// æ£€æµ‹å›¾é›†æœåŠ¡æ˜¯å¦å¯ç”¨ï¼ˆå¿«é€Ÿæ£€æµ‹ï¼Œç”¨äºåˆå§‹åŠ è½½ï¼‰
async function checkServiceAvailability(): Promise<boolean> {
  try {
    const controller = new AbortController()
    const timeoutId = setTimeout(() => controller.abort(), 2000) // 2ç§’å¿«é€Ÿè¶…æ—¶ï¼Œé¿å…å½±å“é¡µé¢åŠ è½½
    
    const response = await fetch(WALLPAPER_SERVICE_CONFIG.fullUrl, {
      method: 'GET',
      headers: {
        'Accept': 'application/json',
      },
      signal: controller.signal
    })
    
    clearTimeout(timeoutId)
    
    if (!response.ok) {
      return false
    }
    
    const data = await response.json()
    if (!data.images || !Array.isArray(data.images) || data.images.length === 0) {
      return false
    }
    
    return true
  } catch (error) {
    return false
  }
}

// æœåŠ¡çŠ¶æ€ç›‘æ§ï¼ˆä»…åœ¨ä½¿ç”¨å¤‡ç”¨å›¾ç‰‡æ—¶è¿è¡Œï¼‰
async function monitorServiceStatus() {
  if (!isUsingFallback) {
    // å¦‚æœä¸æ˜¯ä½¿ç”¨å¤‡ç”¨å›¾ç‰‡ï¼Œåœæ­¢ç›‘æ§
    stopServiceMonitoring()
    return
  }
  
  console.log('ğŸ” æ£€æŸ¥å›¾é›†æœåŠ¡çŠ¶æ€...')
  const isServiceAvailable = await checkServiceAvailability()
  
  if (isServiceAvailable) {
    console.log('âœ… å›¾é›†æœåŠ¡å·²æ¢å¤ï¼åˆ‡æ¢å›åŠ¨æ€å›¾åº“')
    
    // åœæ­¢æœåŠ¡ç›‘æ§
    stopServiceMonitoring()
    
    // é‡æ–°è·å–åŠ¨æ€å›¾åº“
    await fetchImageLibrary()
    
    // ç«‹å³åˆ‡æ¢åˆ°åŠ¨æ€å›¾ç‰‡
    if (!isUsingFallback && currentImages.length > 0) {
      await displayRandomImage()
    }
  }
}

// åœæ­¢æœåŠ¡ç›‘æ§
function stopServiceMonitoring() {
  if (serviceCheckIntervalId) {
    clearInterval(serviceCheckIntervalId)
    serviceCheckIntervalId = null
    console.log('ğŸ“´ åœæ­¢å›¾é›†æœåŠ¡ç›‘æ§')
  }
}

// å¯åŠ¨æœåŠ¡ç›‘æ§ï¼ˆä»…åœ¨åˆ‡æ¢åˆ°å¤‡ç”¨å›¾ç‰‡æ—¶å¯åŠ¨ï¼‰
function startServiceMonitoring() {
  if (!serviceCheckIntervalId) {
    serviceCheckIntervalId = window.setInterval(monitorServiceStatus, SERVICE_CHECK_INTERVAL)
    console.log('ğŸ‘ï¸ å¯åŠ¨å›¾é›†æœåŠ¡ç›‘æ§ï¼ˆ15ç§’æ£€æµ‹ä¸€æ¬¡ï¼‰')
  }
}

// è·å–å¤‡ç”¨å›¾ç‰‡åˆ—è¡¨
function getFallbackImages(): string[] {
  // ä» Wallaper.ts å¯¼å…¥çš„å¤‡ç”¨å›¾ç‰‡
  const fallbackImages = [
    "https://img.xxdevops.cn/blog/wallpaper/bg01.webp", 
  ]
  return fallbackImages
}

// ä»å›¾é›†æœåŠ¡å™¨è·å–å›¾åº“åˆ—è¡¨
async function fetchImageLibrary() {
  try {
    const images = await fetchDynamicWallpapers()
    
    // æ£€æŸ¥æ˜¯å¦è·å–åˆ°æœ‰æ•ˆçš„åŠ¨æ€å›¾ç‰‡ï¼ˆéå¤‡ç”¨å›¾ç‰‡ï¼‰
    const fallbackImages = getFallbackImages()
    const isDynamicImages = images.some(img => !fallbackImages.includes(img))
    
    if (isDynamicImages && images.length > 0) {
      // æˆåŠŸè·å–åˆ°åŠ¨æ€å›¾åº“
      currentImages = images
      lastSuccessfulFetch = Date.now()
      
      if (isUsingFallback) {
        console.log('âœ… å›¾é›†æœåŠ¡å·²æ¢å¤ï¼Œåˆ‡æ¢å›åŠ¨æ€å›¾åº“')
        isUsingFallback = false
        // åœæ­¢æœåŠ¡ç›‘æ§
        stopServiceMonitoring()
      }
      
      console.log(`ğŸ“š åŠ¨æ€å›¾åº“å·²æ›´æ–°: ${images.length} å¼ å›¾ç‰‡`)
    } else {
      // æ²¡æœ‰è·å–åˆ°æœ‰æ•ˆçš„åŠ¨æ€å›¾ç‰‡ï¼Œä½¿ç”¨å¤‡ç”¨å›¾ç‰‡
      if (!isUsingFallback) {
        console.log('âš ï¸ å›¾é›†æœåŠ¡ä¸å¯ç”¨ï¼Œåˆ‡æ¢åˆ°å¤‡ç”¨å›¾ç‰‡')
        currentImages = fallbackImages
        isUsingFallback = true
        // å¯åŠ¨æœåŠ¡ç›‘æ§
        startServiceMonitoring()
      }
    }
  } catch (error) {
    console.warn('è·å–å›¾åº“å¤±è´¥ï¼Œä½¿ç”¨å¤‡ç”¨å›¾ç‰‡:', error)
    
    if (!isUsingFallback) {
      currentImages = getFallbackImages()
      isUsingFallback = true
      // å¯åŠ¨æœåŠ¡ç›‘æ§
      startServiceMonitoring()
    }
  }
}

onMounted(async () => {
  console.log('ğŸ–¼ï¸ åŠ¨æ€å£çº¸ç®¡ç†å™¨å¯åŠ¨')
  
  // å¿«é€Ÿæ£€æµ‹æœåŠ¡çŠ¶æ€ï¼ˆ1ç§’è¶…æ—¶ï¼Œé¿å…é¡µé¢ç­‰å¾…å¤ªä¹…ï¼‰
  console.log('ğŸ” å¿«é€Ÿæ£€æµ‹å›¾é›†æœåŠ¡çŠ¶æ€...')
  
  try {
    const controller = new AbortController()
    const timeoutId = setTimeout(() => controller.abort(), 1000) // 1ç§’å¿«é€Ÿæ£€æµ‹
    
    const response = await fetch(WALLPAPER_SERVICE_CONFIG.fullUrl, {
      method: 'GET',
      headers: { 'Accept': 'application/json' },
      signal: controller.signal
    })
    
    clearTimeout(timeoutId)
    
    if (response.ok) {
      // æœåŠ¡å¯ç”¨ï¼šç›´æ¥è·å–å¹¶æ˜¾ç¤ºåŠ¨æ€å›¾ç‰‡
      console.log('âœ… å›¾é›†æœåŠ¡å¯ç”¨ï¼Œä½¿ç”¨åŠ¨æ€å£çº¸')
      await fetchImageLibrary()
      
      if (!isUsingFallback && currentImages.length > 0) {
        await displayRandomImage()
      }
      
      // è®¾ç½®å®šæ—¶å™¨ï¼šæ¯60ç§’æ›´æ–°å›¾åº“
      fetchLibraryIntervalId = window.setInterval(fetchImageLibrary, FETCH_LIBRARY_INTERVAL)
    } else {
      throw new Error('æœåŠ¡å“åº”å¼‚å¸¸')
    }
  } catch (error) {
    // æœåŠ¡ä¸å¯ç”¨ï¼šä½¿ç”¨å¤‡ç”¨å›¾ç‰‡
    console.log('âŒ å›¾é›†æœåŠ¡ä¸å¯ç”¨ï¼Œä½¿ç”¨å¤‡ç”¨å£çº¸')
    currentImages = getFallbackImages()
    isUsingFallback = true
    await displayRandomImage()
    
    // å¯åŠ¨æœåŠ¡ç›‘æ§ï¼Œç­‰å¾…æœåŠ¡æ¢å¤
    startServiceMonitoring()
  }
  
  // è®¾ç½®å®šæ—¶å™¨ï¼šæ¯10ç§’åˆ‡æ¢å›¾ç‰‡
  switchImageIntervalId = window.setInterval(displayRandomImage, SWITCH_IMAGE_INTERVAL)
})

onUnmounted(() => {
  // æ¸…ç†å›¾åº“è·å–å®šæ—¶å™¨
  if (fetchLibraryIntervalId) {
    clearInterval(fetchLibraryIntervalId)
    fetchLibraryIntervalId = null
  }
  
  // æ¸…ç†å›¾ç‰‡åˆ‡æ¢å®šæ—¶å™¨  
  if (switchImageIntervalId) {
    clearInterval(switchImageIntervalId)
    switchImageIntervalId = null
  }
  
  // æ¸…ç†æœåŠ¡æ£€æµ‹å®šæ—¶å™¨
  stopServiceMonitoring()
  
  console.log('ğŸ–¼ï¸ åŠ¨æ€å£çº¸ç®¡ç†å™¨å·²åœæ­¢')
})
</script>

<style>
/* å£çº¸æ»‘åŠ¨è¿‡æ¸¡æ ·å¼ - ç¡®ä¿èƒŒæ™¯å›¾ç‰‡å±‚æ¬¡æ­£ç¡® */
.tk-banner .tk-banner__bg,
.tk-banner .tk-banner-bg,
.tk-banner [class*="banner"][class*="bg"],
.banner-bg,
.tk-banner-bg,
.background-image {
  background-blend-mode: normal;
  /* ç¡®ä¿å¤šå±‚èƒŒæ™¯æ­£ç¡®æ˜¾ç¤º */
}

/* ç¡®ä¿èƒŒæ™¯å›¾ç‰‡å®¹å™¨æœ‰è¶³å¤Ÿçš„å±‚çº§ */
[style*="background-image"] {
  position: relative;
  overflow: hidden;
}

/* æå‡BannerèƒŒæ™¯çš„ä¼˜å…ˆçº§ */
.tk-banner {
  position: relative;
  z-index: 0;
}
</style>